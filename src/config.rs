use anyhow::anyhow;
use code_api::config::{Extension, SystemContext};
use lazy_regex::regex;
use serde::{Deserialize, Serialize};
use tokio::fs;
use tracing::error;

use crate::jinja::Generator;

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
#[serde(untagged)]
pub enum ExtensionType {
    V1(Extension),
    V2(String),
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
#[serde(default)]
pub struct Config {
    pub vscode_version: String,
    pub autogen_warning: Option<String>,
    pub extensions: Vec<ExtensionType>,
    pub system: Option<SystemContext>,
    #[serde(skip)]
    pub(crate) handled_extensions: Vec<Extension>,
}

impl Config {
    pub async fn from_file(path: &str) -> anyhow::Result<Self> {
        let content = fs::read_to_string(path).await?;
        Self::new(&content)
    }

    pub fn new(content: &str) -> anyhow::Result<Self> {
        let mut obj: Config = toml::from_str(content)?;
        let reg = regex!(r#"(\d+.\d+.\d+)(.*)?"#)
            .captures(&obj.vscode_version)
            .ok_or(anyhow!(format!("bad code version: {}", obj.vscode_version)))
            .unwrap();
        assert_eq!(3, reg.len());

        obj.vscode_version = reg[1].to_string();
        let extensions = std::mem::take(&mut obj.extensions);
        for item in extensions {
            match item {
                ExtensionType::V1(v) => obj.handled_extensions.push(v),
                ExtensionType::V2(v) => {
                    let item = v.split_once(".");
                    match item {
                        Some((publisher, extension)) => obj.handled_extensions.push(Extension {
                            publisher_name: publisher.to_string(),
                            extension_name: extension.to_string(),
                            asset_url: None,
                            system: None,
                        }),
                        None => {
                            error!("config error: {v} is not a valid format");
                        }
                    };
                }
            }
        }

        obj.handled_extensions.iter_mut().for_each(|item| {
            if item.system.is_none() {
                item.system.clone_from(&obj.system);
            }
        });

        obj.handled_extensions.iter_mut().for_each(|item| {
            if item.publisher_name.as_str() == "vadimcn"
                && item.extension_name.as_str() == "vscode-lldb"
            {
                item.asset_url = Some(Generator::CODELLDB.1.into());
            }
        });

        Ok(obj)
    }

    #[inline]
    fn get_idx(&self, publisher_name: &str, extension_name: &str) -> Option<usize> {
        self.handled_extensions.iter().position(|item| {
            item.extension_name.to_lowercase() == extension_name.to_lowercase()
                && item.publisher_name.to_lowercase() == publisher_name.to_lowercase()
        })
    }

    pub fn get_system_ctx(
        &self,
        publisher_name: &str,
        extension_name: &str,
    ) -> Option<SystemContext> {
        match self.get_idx(publisher_name, extension_name) {
            Some(idx) => self.handled_extensions[idx].system.clone(),
            None => None,
        }
    }

    pub fn get_asset_url(&self, publisher_name: &str, extension_name: &str) -> Option<String> {
        match self.get_idx(publisher_name, extension_name) {
            Some(idx) => self.handled_extensions[idx].asset_url.clone(),
            None => None,
        }
    }

    pub fn contains(&self, publisher_name: &str, extension_name: &str) -> bool {
        self.get_idx(publisher_name, extension_name).is_some()
    }
}

#[cfg(test)]
mod test {
    use std::str::FromStr;

    use super::*;

    #[test]
    fn test_version() {
        let c = [
            r#"vscode_version = "0.1.23""#,
            r#"vscode_version = "101.20.0""#,
            r#"vscode_version = "1.84.4""#,
            r#"vscode_version = "1.86.2.24057""#,
            r#"vscode_version = "1.84.4-preview""#,
            r#"vscode_version = "1.86.2.24057-preview""#,
        ];

        for i in c {
            let i = Config::new(i).unwrap();
            let _ = semver::Version::from_str(&i.vscode_version).unwrap();
        }
    }

    #[test]
    fn test_config() {
        let c = [
            r##"
vscode_version = "1.84.2"
autogen_warning = "# Warning, this file is autogenerated by nix4vscode. Don't modify this manually."

[[extensions]]
publisher_name = "ms-python"
extension_name = "debugpy"
        "##,
            r##"
vscode_version = "1.84.2"

extensions = [
    "ms-python.debugy",
    { publisher_name = "ms-python", extension_name = "debugpy" }
]
            "##,
        ];

        for c in c {
            Config::new(c).unwrap();
        }
    }
}
